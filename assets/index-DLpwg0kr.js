class m{static read_bytes(o,l){const R=new m;return R.buf=o.getUint32(l,!0),R.buf_len=o.getUint32(l+4,!0),R}static read_bytes_array(o,l,R){const w=[];for(let e=0;e<R;e++)w.push(m.read_bytes(o,l+8*e));return w}}class E{static read_bytes(o,l){const R=new E;return R.buf=o.getUint32(l,!0),R.buf_len=o.getUint32(l+4,!0),R}static read_bytes_array(o,l,R){const w=[];for(let e=0;e<R;e++)w.push(E.read_bytes(o,l+8*e));return w}}const D=0,x=1;class O{static read_bytes(o,l){return new O(o.getBigUint64(l,!0),o.getUint8(l+8),o.getUint32(l+16,!0),o.getBigUint64(l+24,!0),o.getUint16(l+36,!0))}constructor(o,l,R,w,e){this.userdata=o,this.eventtype=l,this.clockid=R,this.timeout=w,this.flags=e}}class A{write_bytes(o,l){o.setBigUint64(l,this.userdata,!0),o.setUint16(l+8,this.error,!0),o.setUint8(l+10,this.eventtype)}constructor(o,l,R){this.userdata=o,this.error=l,this.eventtype=R}}let S=class{enable(o){this.log=C(o===void 0?!0:o,this.prefix)}get enabled(){return this.isEnabled}constructor(o){this.isEnabled=o,this.prefix="wasi:",this.enable(o)}};function C(g,o){return g?console.log.bind(console,"%c%s","color: #265BA0",o):()=>{}}const y=new S(!1);class p extends Error{constructor(o){super("exit with exit code "+o),this.code=o}}let T=class{start(o){this.inst=o;try{return o.exports._start(),0}catch(l){if(l instanceof p)return l.code;throw l}}initialize(o){this.inst=o,o.exports._initialize&&o.exports._initialize()}constructor(o,l,R,w={}){this.args=[],this.env=[],this.fds=[],y.enable(w.debug),this.args=o,this.env=l,this.fds=R;const e=this;this.wasiImport={args_sizes_get(t,r){const n=new DataView(e.inst.exports.memory.buffer);n.setUint32(t,e.args.length,!0);let s=0;for(const f of e.args)s+=f.length+1;return n.setUint32(r,s,!0),y.log(n.getUint32(t,!0),n.getUint32(r,!0)),0},args_get(t,r){const n=new DataView(e.inst.exports.memory.buffer),s=new Uint8Array(e.inst.exports.memory.buffer),f=r;for(let i=0;i<e.args.length;i++){n.setUint32(t,r,!0),t+=4;const a=new TextEncoder().encode(e.args[i]);s.set(a,r),n.setUint8(r+a.length,0),r+=a.length+1}return y.enabled&&y.log(new TextDecoder("utf-8").decode(s.slice(f,r))),0},environ_sizes_get(t,r){const n=new DataView(e.inst.exports.memory.buffer);n.setUint32(t,e.env.length,!0);let s=0;for(const f of e.env)s+=new TextEncoder().encode(f).length+1;return n.setUint32(r,s,!0),y.log(n.getUint32(t,!0),n.getUint32(r,!0)),0},environ_get(t,r){const n=new DataView(e.inst.exports.memory.buffer),s=new Uint8Array(e.inst.exports.memory.buffer),f=r;for(let i=0;i<e.env.length;i++){n.setUint32(t,r,!0),t+=4;const a=new TextEncoder().encode(e.env[i]);s.set(a,r),n.setUint8(r+a.length,0),r+=a.length+1}return y.enabled&&y.log(new TextDecoder("utf-8").decode(s.slice(f,r))),0},clock_res_get(t,r){let n;switch(t){case 1:{n=5000n;break}case 0:{n=1000000n;break}default:return 52}return new DataView(e.inst.exports.memory.buffer).setBigUint64(r,n,!0),0},clock_time_get(t,r,n){const s=new DataView(e.inst.exports.memory.buffer);if(t===0)s.setBigUint64(n,BigInt(new Date().getTime())*1000000n,!0);else if(t==1){let f;try{f=BigInt(Math.round(performance.now()*1e6))}catch{f=0n}s.setBigUint64(n,f,!0)}else s.setBigUint64(n,0n,!0);return 0},fd_advise(t,r,n,s){return e.fds[t]!=null?0:8},fd_allocate(t,r,n){return e.fds[t]!=null?e.fds[t].fd_allocate(r,n):8},fd_close(t){if(e.fds[t]!=null){const r=e.fds[t].fd_close();return e.fds[t]=void 0,r}else return 8},fd_datasync(t){return e.fds[t]!=null?e.fds[t].fd_sync():8},fd_fdstat_get(t,r){if(e.fds[t]!=null){const{ret:n,fdstat:s}=e.fds[t].fd_fdstat_get();return s?.write_bytes(new DataView(e.inst.exports.memory.buffer),r),n}else return 8},fd_fdstat_set_flags(t,r){return e.fds[t]!=null?e.fds[t].fd_fdstat_set_flags(r):8},fd_fdstat_set_rights(t,r,n){return e.fds[t]!=null?e.fds[t].fd_fdstat_set_rights(r,n):8},fd_filestat_get(t,r){if(e.fds[t]!=null){const{ret:n,filestat:s}=e.fds[t].fd_filestat_get();return s?.write_bytes(new DataView(e.inst.exports.memory.buffer),r),n}else return 8},fd_filestat_set_size(t,r){return e.fds[t]!=null?e.fds[t].fd_filestat_set_size(r):8},fd_filestat_set_times(t,r,n,s){return e.fds[t]!=null?e.fds[t].fd_filestat_set_times(r,n,s):8},fd_pread(t,r,n,s,f){const i=new DataView(e.inst.exports.memory.buffer),a=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const d=m.read_bytes_array(i,r,n);let c=0;for(const u of d){const{ret:_,data:b}=e.fds[t].fd_pread(u.buf_len,s);if(_!=0)return i.setUint32(f,c,!0),_;if(a.set(b,u.buf),c+=b.length,s+=BigInt(b.length),b.length!=u.buf_len)break}return i.setUint32(f,c,!0),0}else return 8},fd_prestat_get(t,r){const n=new DataView(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const{ret:s,prestat:f}=e.fds[t].fd_prestat_get();return f?.write_bytes(n,r),s}else return 8},fd_prestat_dir_name(t,r,n){if(e.fds[t]!=null){const{ret:s,prestat:f}=e.fds[t].fd_prestat_get();if(f==null)return s;const i=f.inner.pr_name;return new Uint8Array(e.inst.exports.memory.buffer).set(i.slice(0,n),r),i.byteLength>n?37:0}else return 8},fd_pwrite(t,r,n,s,f){const i=new DataView(e.inst.exports.memory.buffer),a=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const d=E.read_bytes_array(i,r,n);let c=0;for(const u of d){const _=a.slice(u.buf,u.buf+u.buf_len),{ret:b,nwritten:h}=e.fds[t].fd_pwrite(_,s);if(b!=0)return i.setUint32(f,c,!0),b;if(c+=h,s+=BigInt(h),h!=_.byteLength)break}return i.setUint32(f,c,!0),0}else return 8},fd_read(t,r,n,s){const f=new DataView(e.inst.exports.memory.buffer),i=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const a=m.read_bytes_array(f,r,n);let d=0;for(const c of a){const{ret:u,data:_}=e.fds[t].fd_read(c.buf_len);if(u!=0)return f.setUint32(s,d,!0),u;if(i.set(_,c.buf),d+=_.length,_.length!=c.buf_len)break}return f.setUint32(s,d,!0),0}else return 8},fd_readdir(t,r,n,s,f){const i=new DataView(e.inst.exports.memory.buffer),a=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){let d=0;for(;;){const{ret:c,dirent:u}=e.fds[t].fd_readdir_single(s);if(c!=0)return i.setUint32(f,d,!0),c;if(u==null)break;if(n-d<u.head_length()){d=n;break}const _=new ArrayBuffer(u.head_length());if(u.write_head_bytes(new DataView(_),0),a.set(new Uint8Array(_).slice(0,Math.min(_.byteLength,n-d)),r),r+=u.head_length(),d+=u.head_length(),n-d<u.name_length()){d=n;break}u.write_name_bytes(a,r,n-d),r+=u.name_length(),d+=u.name_length(),s=u.d_next}return i.setUint32(f,d,!0),0}else return 8},fd_renumber(t,r){if(e.fds[t]!=null&&e.fds[r]!=null){const n=e.fds[r].fd_close();return n!=0?n:(e.fds[r]=e.fds[t],e.fds[t]=void 0,0)}else return 8},fd_seek(t,r,n,s){const f=new DataView(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const{ret:i,offset:a}=e.fds[t].fd_seek(r,n);return f.setBigInt64(s,a,!0),i}else return 8},fd_sync(t){return e.fds[t]!=null?e.fds[t].fd_sync():8},fd_tell(t,r){const n=new DataView(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const{ret:s,offset:f}=e.fds[t].fd_tell();return n.setBigUint64(r,f,!0),s}else return 8},fd_write(t,r,n,s){const f=new DataView(e.inst.exports.memory.buffer),i=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const a=E.read_bytes_array(f,r,n);let d=0;for(const c of a){const u=i.slice(c.buf,c.buf+c.buf_len),{ret:_,nwritten:b}=e.fds[t].fd_write(u);if(_!=0)return f.setUint32(s,d,!0),_;if(d+=b,b!=u.byteLength)break}return f.setUint32(s,d,!0),0}else return 8},path_create_directory(t,r,n){const s=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const f=new TextDecoder("utf-8").decode(s.slice(r,r+n));return e.fds[t].path_create_directory(f)}else return 8},path_filestat_get(t,r,n,s,f){const i=new DataView(e.inst.exports.memory.buffer),a=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const d=new TextDecoder("utf-8").decode(a.slice(n,n+s)),{ret:c,filestat:u}=e.fds[t].path_filestat_get(r,d);return u?.write_bytes(i,f),c}else return 8},path_filestat_set_times(t,r,n,s,f,i,a){const d=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const c=new TextDecoder("utf-8").decode(d.slice(n,n+s));return e.fds[t].path_filestat_set_times(r,c,f,i,a)}else return 8},path_link(t,r,n,s,f,i,a){const d=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null&&e.fds[f]!=null){const c=new TextDecoder("utf-8").decode(d.slice(n,n+s)),u=new TextDecoder("utf-8").decode(d.slice(i,i+a)),{ret:_,inode_obj:b}=e.fds[t].path_lookup(c,r);return b==null?_:e.fds[f].path_link(u,b,!1)}else return 8},path_open(t,r,n,s,f,i,a,d,c){const u=new DataView(e.inst.exports.memory.buffer),_=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const b=new TextDecoder("utf-8").decode(_.slice(n,n+s));y.log(b);const{ret:h,fd_obj:N}=e.fds[t].path_open(r,b,f,i,a,d);if(h!=0)return h;e.fds.push(N);const U=e.fds.length-1;return u.setUint32(c,U,!0),0}else return 8},path_readlink(t,r,n,s,f,i){const a=new DataView(e.inst.exports.memory.buffer),d=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const c=new TextDecoder("utf-8").decode(d.slice(r,r+n));y.log(c);const{ret:u,data:_}=e.fds[t].path_readlink(c);if(_!=null){const b=new TextEncoder().encode(_);if(b.length>f)return a.setUint32(i,0,!0),8;d.set(b,s),a.setUint32(i,b.length,!0)}return u}else return 8},path_remove_directory(t,r,n){const s=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const f=new TextDecoder("utf-8").decode(s.slice(r,r+n));return e.fds[t].path_remove_directory(f)}else return 8},path_rename(t,r,n,s,f,i){const a=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null&&e.fds[s]!=null){const d=new TextDecoder("utf-8").decode(a.slice(r,r+n)),c=new TextDecoder("utf-8").decode(a.slice(f,f+i));let{ret:u,inode_obj:_}=e.fds[t].path_unlink(d);if(_==null)return u;if(u=e.fds[s].path_link(c,_,!0),u!=0&&e.fds[t].path_link(d,_,!0)!=0)throw"path_link should always return success when relinking an inode back to the original place";return u}else return 8},path_symlink(t,r,n,s,f){const i=new Uint8Array(e.inst.exports.memory.buffer);return e.fds[n]!=null?(new TextDecoder("utf-8").decode(i.slice(t,t+r)),new TextDecoder("utf-8").decode(i.slice(s,s+f)),58):8},path_unlink_file(t,r,n){const s=new Uint8Array(e.inst.exports.memory.buffer);if(e.fds[t]!=null){const f=new TextDecoder("utf-8").decode(s.slice(r,r+n));return e.fds[t].path_unlink_file(f)}else return 8},poll_oneoff(t,r,n){if(n===0)return 28;if(n>1)return y.log("poll_oneoff: only a single subscription is supported"),58;const s=new DataView(e.inst.exports.memory.buffer),f=O.read_bytes(s,t),i=f.eventtype,a=f.clockid,d=f.timeout;if(i!==D)return y.log("poll_oneoff: only clock subscriptions are supported"),58;let c;if(a===1)c=()=>BigInt(Math.round(performance.now()*1e6));else if(a===0)c=()=>BigInt(new Date().getTime())*1000000n;else return 28;const u=f.flags&x?d:c()+d;for(;u>c(););return new A(f.userdata,0,i).write_bytes(s,r),0},proc_exit(t){throw new p(t)},proc_raise(t){throw"raised signal "+t},sched_yield(){},random_get(t,r){const n=new Uint8Array(e.inst.exports.memory.buffer).subarray(t,t+r);if("crypto"in globalThis&&(typeof SharedArrayBuffer>"u"||!(e.inst.exports.memory.buffer instanceof SharedArrayBuffer)))for(let s=0;s<r;s+=65536)crypto.getRandomValues(n.subarray(s,s+65536));else for(let s=0;s<r;s++)n[s]=Math.random()*256|0},sock_recv(t,r,n){throw"sockets not supported"},sock_send(t,r,n){throw"sockets not supported"},sock_shutdown(t,r){throw"sockets not supported"},sock_accept(t,r){throw"sockets not supported"}}}};export{T as WASI,p as WASIProcExit};
